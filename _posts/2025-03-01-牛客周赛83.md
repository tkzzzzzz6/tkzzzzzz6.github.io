---
title: 2025-02-25-牛客周赛 83 
tags: 算法练习
---

# 2025-02-25-牛客周赛 83

> 官方题解
> [牛客周赛 83 - 题解_牛客博客](https://blog.nowcoder.net/n/d1c25e46a4854a379e3672e71d3be671)

# A [和猫猫一起起舞！](https://ac.nowcoder.com/acm/contest/102896/A)

> ![1741003226383FLVIblfE0oZNGgxV74VcmrTpn9d.png](https://fastly.jsdelivr.net/gh/tkzzzzzz6/imagehost@main/blog/1741003226383FLVIblfE0oZNGgxV74VcmrTpn9d.png)

### C++

```cpp
void solve(){
    char c;
    cin >> c;
    if(c == 'U' or c == 'D') cout << 'L';
    else cout << 'U';
    cout << endl;
    return;
}
```

### python

```python
print("L" if input() in list("UD") else "U")
```

# B [冒险猫猫参上！！](https://ac.nowcoder.com/acm/contest/102896/B)

> ![17410034453801741003444954.png](https://fastly.jsdelivr.net/gh/tkzzzzzz6/imagehost@main/blog/17410034453801741003444954.png)

```cpp
void solve(){
    int n;
    cin >> n;
    for(int i = 0; i < n; ++i){ // ++i是在循环里一个常数优化，可以不管
        cout << i % 2 + 1 << " ";
    }
    cout << endl;
}
```

# C  [泉神，启动！！！](https://ac.nowcoder.com/acm/contest/102896/C)

>![17410035073811741003507023.png](https://fastly.jsdelivr.net/gh/tkzzzzzz6/imagehost@main/blog/17410035073811741003507023.png)

```cpp
void solve(){
    string s; cin >> s;
    cout << (LL)(pow(10, s.length()) + 1) << endl;
    return;
}
```

# D [大预言家！！！！](https://ac.nowcoder.com/acm/contest/102896/D)

> ![17410035273871741003527363.png](https://fastly.jsdelivr.net/gh/tkzzzzzz6/imagehost@main/blog/17410035273871741003527363.png)

```python
def solve():
    t = int(input())
    n = int(math.ceil(math.sqrt(t)))
    n += 1 if n % 2 == 0 else 0 # 右上角定位，强制取大于等于t秒的第一个抵达秒数是一个奇数的平方的位置
    tmp = n * n - t
    if tmp < n: # 上边
        y = n // 2
        x = (n // 2) - tmp
    elif tmp < (2 * n - 1): # 左边
        tmp -= n
        x = -(n // 2)
        y = (n // 2 - 1) - tmp
    elif tmp < (3 * n - 2): # 下边
        tmp -= (2 * n - 1)
        y = -(n // 2)
        x = -(n // 2 - 1) + tmp
    else: # 只剩下右边
        base = (n - 2) * (n - 2)
        tmp = t - base
        x = (n // 2)
        y = (n // 2) - tmp
    print(x, y)
    return
```

# E [全都要！！！！！](https://ac.nowcoder.com/acm/contest/102896/E)

> ![17410035633811741003563230.png](https://fastly.jsdelivr.net/gh/tkzzzzzz6/imagehost@main/blog/17410035633811741003563230.png)

```cpp
void solve(){
    int n, k; cin >> n >> k;
    vector<LL> a(n + 5);
    for(int i = 1; i <= n; ++i){
        cin >> a[i];
    }
    vector<vector<LL>> f(n + 5, vector<LL>(k + 5, -1145141919810)); // 魔法的数字，助您日入百亿
    LL R = -1145141919810;
    f[0][0] = 0;
    for(int i = 1; i <= n; ++i){
        for(int j = 1; j <= min(i, k); ++j){
            for(int p = max(0, i - 6); p <= i - 1; ++p){
                f[i][j] = max(f[i][j], f[p][j - 1] + a[i]);
            }
        }
        R = max(R, f[i][k]);
    }
    cout << R << endl;
}
```

# F [水题！！！！！！](https://ac.nowcoder.com/acm/contest/102896/F)

> ![17410036113861741003610943.png](https://fastly.jsdelivr.net/gh/tkzzzzzz6/imagehost@main/blog/17410036113861741003610943.png)

```cpp
struct Node{
    int x, y, nowT, abi;
    bool operator<(const Node& y) const{
        return y.nowT < nowT;
    }
};

void solve(){
    int n, m, t;
    cin >> n >> m >> t;
    ++t; // 我们默认水流直接进入新节点，所以t自增比较方便。
    vector<vector<char>> G(n + 5, vector<char>(m + 5, '^'));
    pair<int, int> stp, enp;
    for(int i = 1; i <= n; ++i){
        for(int j = 1; j <= m; ++j){
            cin >> G[i][j];
            if(G[i][j] == '*') stp = {i, j};
            if(G[i][j] == '%') enp = {i, j};
        }
    }
    priority_queue<Node> q;
    q.push({stp.first, stp.second, 0, 1});
    vector<vector<bool>> vis(n + 5, vector<bool>(m + 5, 0));
    while(!q.empty()){
        auto [x, y, nowT, can] = q.top();
        q.pop();
        if(can != 1) if(vis[x][y]) continue;
        vis[x][y] = true;
        if(G[x][y] == '%'){ // 搜到了就直接强制终止，因为堆和模型的性质，一定是最优的之一。
            cout << nowT << endl;
            return;
        }
        if(G[x + 1][y] == '#'){
            if(can and !vis[x + 1][y]) q.push({x + 1, y, nowT + t, 1}); // 塞
            if(y + 1 <= m and G[x][y + 1] != '#') q.push({x, y + 1, nowT + 1, 0}); // 左右扩散判定
            if(y - 1 >= 1 and G[x][y - 1] != '#') q.push({x, y - 1, nowT + 1, 0});
        }else{
            if(x + 1 <= n) q.push({x + 1, y, nowT + 1, 1}); // 垂直扩散判定
        }
    }
    cout << -1 << endl;
    return;
}
```
