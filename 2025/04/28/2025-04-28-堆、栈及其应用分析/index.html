<!DOCTYPE html>
<html lang="zh">
  <head>
    
    <meta charset="UTF-8">
    <title>2025-04-28-堆、栈及其应用分析 - TK的小站</title>
    <link rel="shortcut icon" href="/static/img/icon.png">
    <link rel="icon" href="/static/img/icon.png" sizes="192x192"/>
    
<link rel="stylesheet" href="/static/kico.css">
<link rel="stylesheet" href="/static/hingle.css">

    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta property="og:site_name" content="TK的小站">
    <meta property="og:title" content="2025-04-28-堆、栈及其应用分析"/>
    
    <style>body:before{ content: ''; background-image: url(https://api.paugram.com/wallpaper?source=gh) }</style>
    
<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="TK的小站" type="application/atom+xml">
</head>

  <body>
    <header>
    <div class="head-title">
        <h4>TK的小站</h4>
    </div>
    <div class="head-action">
        <div class="toggle-btn"></div>
        <div class="light-btn"></div>
        <div class="search-btn"></div>
    </div>
    <form class="head-search" method="post">
        <input type="text" name="s" placeholder="搜索什么？">
    </form>
    <nav class="head-menu">
        <a href="/">首页</a>
        <div class="has-child">
            <a href>分类</a>
            <div class="sub-menu">
                <a class="category-link" href="/categories/%E8%BF%9B%E5%87%BB%E7%9A%84%E7%A0%81%E5%86%9C/">进击的码农</a>
            </div>
        </div>
        
            <a href="/about">关于我</a>
        
            <a href="/friends">朋友们</a>
        
            <a href="/tools">工具推荐</a>
        
    </nav>
</header>

    <main>
    <div class="wrap min">
        <section class="post-title">
            <h2>2025-04-28-堆、栈及其应用分析</h2>
            <div class="post-meta">
                <time class="date">2025.04.28</time>
            
            </div>
        </section>
        <article class="post-content">
        
            <h1 id="堆、栈及其应用分析"><a href="#堆、栈及其应用分析" class="headerlink" title="堆、栈及其应用分析"></a>堆、栈及其应用分析</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linfangnan/p/12450061.html">栈结构解析及其应用 - 乌漆 WhiteMoon - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moonandstar08/p/4934597.html">堆栈信息分析 - moonandstar08 - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tolin/p/14982094.html">什么是堆?什么是栈?他们之间有什么区别和联系? - tolin - 博客园</a></li>
</ul>
</blockquote>
<h1 id="堆-Heap-与-栈-Stack-概述"><a href="#堆-Heap-与-栈-Stack-概述" class="headerlink" title="堆 (Heap) 与 栈 (Stack) 概述"></a>堆 (Heap) 与 栈 (Stack) 概述</h1><ul>
<li><p><strong>栈（Stack）</strong></p>
</li>
<li><p><strong>数据结构视角</strong>：一种受限的线性结构，只能在同一端（栈顶）进行插入（Push）和删除（Pop），遵循 “后进先出”（LIFO）原则。</p>
</li>
<li><p><strong>内存视角</strong>：栈区由操作系统自动分配与回收，用于存储函数调用时的局部变量、函数参数、返回地址等信息。栈空间连续，访问和分配速度极快，但容量有限（通常几 MB），每个线程都有独立栈空间。</p>
</li>
<li><p><strong>堆（Heap）</strong></p>
<ul>
<li><strong>数据结构视角</strong>：一种近似完全二叉树的优先队列结构（最大堆或最小堆），常用于按优先级提取元素。</li>
<li><strong>内存视角</strong>：堆区用于动态分配内存，程序运行时可调用 <code>new</code>/<code>malloc</code>（C++）或由运行时自动分配（Python）来获取；释放时需 <code>delete</code>/<code>free</code> 或由垃圾回收负责。堆空间大但分配、释放开销较大，可能产生内存碎片。</li>
</ul>
</li>
</ul>
<h2 id="数据结构视角"><a href="#数据结构视角" class="headerlink" title="数据结构视角"></a>数据结构视角</h2><p><strong>栈</strong>：一种线性受限结构，只允许在栈顶进行插入（Push）和删除（Pop），遵循“后进先出”（LIFO）原则。常用操作包括 <code>push</code>（进栈）、<code>pop</code>（出栈）、<code>top</code>（取栈顶）等，这些操作时间复杂度通常为 O(1)。栈可用数组（顺序栈）或链表（链式栈）实现，适用于函数调用、递归计算、撤销操作等场景。</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/stack/">栈 - OI Wiki</a></li>
</ul>
</blockquote>
<h3 id="使用数组模拟栈"><a href="#使用数组模拟栈" class="headerlink" title="使用数组模拟栈"></a>使用数组模拟栈</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 这里使用 st[0] (即 *st) 代表栈中元素数量，同时也是栈顶下标</span>

<span class="token comment">// 压栈 ：</span>
st<span class="token punctuation">[</span><span class="token operator">++</span><span class="token operator">*</span>st<span class="token punctuation">]</span> <span class="token operator">=</span> var1<span class="token punctuation">;</span>
<span class="token comment">// 取栈顶 ：</span>
<span class="token keyword">int</span> u <span class="token operator">=</span> st<span class="token punctuation">[</span><span class="token operator">*</span>st<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 弹栈 ：注意越界问题, *st == 0 时不能继续弹出</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>st<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">*</span>st<span class="token punctuation">;</span>
<span class="token comment">// 清空栈</span>
<span class="token operator">*</span>st <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="C-STL-中的栈"><a href="#C-STL-中的栈" class="headerlink" title="C++ STL 中的栈"></a>C++ STL 中的栈</h3><p>C++ 中的 STL 也提供了一个容器 <code>std::stack</code>，使用前需要引入 <code>stack</code> 头文件。</p>
<p>STL 中的 <code>stack</code> 容器提供了一众成员函数以供调用，其中较为常用的有：</p>
<ul>
<li><p>元素访问</p>
<ul>
<li><code>st.top()</code> 返回栈顶</li>
</ul>
</li>
<li><p>修改</p>
<ul>
<li><code>st.push()</code> 插入传入的参数到栈顶</li>
<li><code>st.pop()</code> 弹出栈顶</li>
</ul>
</li>
<li><p>容量</p>
<ul>
<li><code>st.empty()</code> 返回是否为空</li>
<li><code>st.size()</code> 返回元素数量</li>
</ul>
</li>
</ul>
<p>此外，<code>std::stack</code> 还提供了一些运算符。较为常用的是使用赋值运算符 <code>=</code> 为 <code>stack</code> 赋值，示例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 新建两个栈 st1 和 st2</span>
std<span class="token double-colon punctuation">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> st1<span class="token punctuation">,</span> st2<span class="token punctuation">;</span>

<span class="token comment">// 为 st1 装入 1</span>
st1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将 st1 赋值给 st2</span>
st2 <span class="token operator">=</span> st1<span class="token punctuation">;</span>

<span class="token comment">// 输出 st2 的栈顶元素</span>
cout <span class="token operator">&lt;&lt;</span> st2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token comment">// 输出: 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="使用-Python-中的-list-模拟栈"><a href="#使用-Python-中的-list-模拟栈" class="headerlink" title="使用 Python 中的 list 模拟栈"></a>使用 Python 中的 list 模拟栈</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">st <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>

<span class="token comment"># 使用 append() 向栈顶添加元素</span>
st<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
st<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment"># &gt;&gt;&gt; st</span>
<span class="token comment"># [5, 1, 4, 2, 3]</span>

<span class="token comment"># 使用 pop 取出栈顶元素</span>
st<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># &gt;&gt;&gt; st</span>
<span class="token comment"># [5, 1, 4, 2]</span>

<span class="token comment"># 使用 clear 清空栈</span>
st<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>堆</strong>（优先队列）: 一种树形结构，即满足堆序性的完全二叉树。每个节点的值都不大于（或不小于）其父节点的值，根节点是最大值（大顶堆）或最小值（小顶堆）。常见操作包括：上浮（shift_up）、下沉（shift_down）、插入（push）和弹出（pop）堆顶元素，以及查询堆顶（top）。堆常用作优先队列，在任务调度、Dijkstra 最短路径、Top-K 计算等场景中非常常见。</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/heap/">堆简介 - OI Wiki</a></li>
</ul>
</blockquote>
<p>堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。</p>
<p>每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。STL 中的 priority_queue 其实就是一个大根堆。</p>
<p>（小根）堆主要支持的操作有：插入一个数、查询最小值、删除最小值、合并两个堆、减小一个元素的值。</p>
<p>一些功能强大的堆（可并堆）还能（高效地）支持 merge 等操作。</p>
<p>一些功能更强大的堆还支持可持久化，也就是对任意历史版本进行查询或者操作，产生新的版本。</p>
<h3 id="C-堆-优先队列：默认大顶堆（priority-queue）："><a href="#C-堆-优先队列：默认大顶堆（priority-queue）：" class="headerlink" title="C++ 堆/优先队列：默认大顶堆（priority_queue）："></a><strong>C++ 堆/优先队列</strong>：默认大顶堆（<code>priority_queue</code>）：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> pq<span class="token punctuation">;</span>
pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> top <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5 (最大值)</span>
pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Python-堆（heapq-最小堆）："><a href="#Python-堆（heapq-最小堆）：" class="headerlink" title="Python 堆（heapq 最小堆）："></a><strong>Python 堆</strong>（<code>heapq</code> 最小堆）：</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> heapq
heap <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
top <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>  <span class="token comment"># 3 (最小值)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如果需要大顶堆，可插入负值或使用第三方实现。</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://algorithm-visualizer.org/brute-force/heapsort">Brute Force Heapsort</a></p>
</blockquote>
<p>堆排序是一种高效的、基于比较的排序算法。它利用了堆这种数据结构的特性。基本思想是：</p>
<ol>
<li><p>**建堆 (Heapify)**：将待排序的序列构建成一个大顶堆（或小顶堆）。此时，堆顶元素就是整个序列的最大值（或最小值）。</p>
</li>
<li><p>**排序 (Sort)**：</p>
<ul>
<li>将堆顶元素与序列末尾的元素交换。</li>
<li>此时，序列末尾的元素即为最大（或最小）值，已经处于正确排序位置。</li>
<li>将剩余的 n-1 个元素重新调整为一个堆。</li>
<li>重复此过程，直到所有元素都排序完毕。</li>
</ul>
</li>
</ol>
<p>堆排序的平均时间复杂度和最坏时间复杂度都是 O(nlogn)。</p>
<h4 id="C-实现堆排序"><a href="#C-实现堆排序" class="headerlink" title="C++ 实现堆排序"></a>C++ 实现堆排序</h4><p>在 C++ 中，可以利用标准库 <code>&lt;algorithm&gt;</code> 中提供的堆操作函数来方便地实现堆排序。</p>
<ul>
<li><code>std::make_heap(first, last)</code>: 将指定范围 <code>[first, last)</code> 内的元素重新排列，使其成为一个大顶堆。</li>
<li><code>std::sort_heap(first, last)</code>: 将一个已经建好的堆 <code>[first, last)</code> 进行排序。它会重复地将堆顶元素（最大值）移动到序列的末尾，并重新调整剩余部分为堆。</li>
</ul>
<p>C++</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span> <span class="token comment">// 包含 make_heap, sort_heap</span></span>

<span class="token keyword">void</span> <span class="token function">print_vector</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Original vector: "</span><span class="token punctuation">;</span>
    <span class="token function">print_vector</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 1. 将 vector 转换成大顶堆</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">make_heap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"After make_heap (top is max): "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  
    <span class="token comment">// 2. 对堆进行排序 (结果为升序)</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">sort_heap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Sorted vector: "</span><span class="token punctuation">;</span>
    <span class="token function">print_vector</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: 1 2 3 4 5 7 8</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Python-实现堆排序"><a href="#Python-实现堆排序" class="headerlink" title="Python 实现堆排序"></a>Python 实现堆排序</h4><p>Python 的 <code>heapq</code> 模块本身不直接提供一个完整的 <code>heapsort</code> 函数，但我们可以很容易地利用其 <code>heappush</code> 和 <code>heappop</code> 来实现。因为 <code>heapq</code> 是最小堆，所以 <code>heappop</code> 总是弹出最小值，天然适合用于升序排序。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> heapq

<span class="token keyword">def</span> <span class="token function">heapsort_asc</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    使用 heapq 实现升序排序
    """</span>
    h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment"># 将所有元素压入堆中</span>
    <span class="token keyword">for</span> value <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
        heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>h<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
    <span class="token comment"># 依次弹出堆中最小的元素，构成有序列表</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Original list: </span><span class="token interpolation"><span class="token punctuation">{</span>data<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

sorted_data <span class="token operator">=</span> heapsort_asc<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Sorted list (ascending): </span><span class="token interpolation"><span class="token punctuation">{</span>sorted_data<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token comment"># 输出: [1, 2, 3, 4, 5, 7, 8]</span>

<span class="token comment"># 原地堆排序 (In-place Heap Sort)</span>
<span class="token comment"># 这更接近于堆排序的经典实现</span>
<span class="token keyword">def</span> <span class="token function">heapsort_inplace</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
    <span class="token comment"># 1. 构建大顶堆 (从最后一个非叶子节点开始)</span>
    <span class="token comment"># 注意：heapq 是最小堆，所以这里通过对负数操作来模拟大顶堆</span>
    <span class="token comment"># 或者我们手动实现大顶堆的 sift_down</span>
    <span class="token comment"># 为了简单，我们还是用 heapq 来理解，但传统实现更高效</span>
    h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> x <span class="token keyword">in</span> arr<span class="token punctuation">:</span>
        heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>h<span class="token punctuation">,</span> x<span class="token punctuation">)</span>
    arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> arr

data_inplace <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>
heapsort_inplace<span class="token punctuation">(</span>data_inplace<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"In-place sorted list: </span><span class="token interpolation"><span class="token punctuation">{</span>data_inplace<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>栈和堆（优先队列）各有特点：</p>
<ul>
<li><strong>数据组织</strong>：栈是线性的、受限的结构，只能从一端操作；堆是树形结构，可快速获取最大或最小元素。</li>
<li><strong>访问效率</strong>：栈操作简单开销小；堆插入/删除需维护堆序（O(log n)）。</li>
<li><strong>应用场景</strong>：栈适合管理临时状态（如函数调用栈、表达式求值、撤销操作）；堆（优先队列）适合按优先级处理元素，如操作系统任务调度、网络请求优先级、算法中的最佳-优先搜索等。</li>
</ul>
<h2 id="内存分配视角"><a href="#内存分配视角" class="headerlink" title="内存分配视角"></a>内存分配视角</h2><p>在程序运行时，内存通常分为<strong>代码区</strong>、<strong>数据区</strong>、<strong>堆区</strong>和<strong>栈区</strong>。其中：</p>
<ul>
<li><strong>栈区</strong>：由系统自动管理，随函数调用而增长，每次函数调用时分配空间给局部变量、函数参数和返回地址。函数返回时，这些空间自动回收。栈分配速度快、开销低，但空间有限（常见几 MB），且每个线程都有独立的栈空间。如果栈空间不足，会导致栈溢出错误。</li>
<li><strong>堆区</strong>：用于动态内存分配，程序员（或运行时）在运行时使用 <code>new</code>/<code>malloc</code> 等申请内存，由程序员 <code>delete</code>/<code>free</code> 释放（在 Python/Java 等语言由垃圾回收自动释放）。堆的可用空间远大于栈，存放<strong>动态对象</strong>。堆内存碎片化的风险更高：频繁的分配和释放可能将大块连续内存切割成许多小碎片，降低利用率。</li>
<li><strong>静态/全局区</strong>：编译时分配，程序运行前即确定，存放全局变量、静态变量和常量，在程序整个生命周期存在。</li>
</ul>
<p><strong>分配方式</strong>：栈的分配和回收速度极快，操作由 CPU 指令自动完成；堆的分配开销较大，一般需要额外的内存管理算法（如自由链表或分代收集），在 C++ 中需要程序员手动释放。Python 中所有对象都分配在堆上，解释器通过引用计数和垃圾回收来管理。</p>
<p><strong>访问效率</strong>：由于栈内存连续、分配固定，因此访问和分配速度更高。堆内存由多个块组成，需额外指针管理，因而略慢于栈访问。此外，栈是线程私有的（线程安全），而堆是所有线程共享的（需注意并发安全）。</p>
<ul>
<li><strong>C++ 栈 vs 堆 分配</strong>：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token comment">// 分配在栈上</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 分配在堆上</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>              <span class="token comment">// 手动释放堆内存</span>
<span class="token punctuation">}</span> <span class="token comment">// 函数返回时，a 的栈空间自动释放，若忘了 delete，则 p 指向的内存泄露</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>Python 对象分配</strong>：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    a <span class="token operator">=</span> <span class="token number">10</span>             <span class="token comment"># 10 是整数对象，存储在堆中；a 是栈帧内的局部引用</span>
    b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>      <span class="token comment"># 列表对象在堆上分配</span>
    <span class="token comment"># 变量 a, b 是存放在函数调用栈帧中的引用，当函数结束，这些引用消失</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Python 不需要显示释放内存，垃圾回收自动回收无用对象。</li>
</ul>
<h2 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h2><h3 id="函数调用与返回"><a href="#函数调用与返回" class="headerlink" title="函数调用与返回"></a>函数调用与返回</h3><p>当程序调用一个函数时，当前上下文（包括当前函数的局部变量、返回地址、CPU 寄存器等）会被“压栈（push）”到栈上；函数执行完成后，栈顶信息被“弹栈（pop）”，程序自动返回调用点并恢复先前状态。这种机制正是栈的典型应用。</p>
<h4 id="C-示例"><a href="#C-示例" class="headerlink" title="C++ 示例"></a>C++ 示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token comment">// 一个示例函数，用于演示栈帧形成</span>
<span class="token keyword">int</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 调用 factorial(n-1) 前，会把当前的 n、返回地址等信息压入栈</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"factorial("</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">") = "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">factorial</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>每次调用 <code>factorial</code> 时，当前函数的局部变量（如 <code>n</code>）和返回地址会压入栈；函数结束时，栈帧被弹出，返回到上一级调用点。</li>
</ul>
<h4 id="Python-示例"><a href="#Python-示例" class="headerlink" title="Python 示例"></a>Python 示例</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token comment"># 递归调用时，Python 会将当前函数帧压入调用栈</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> factorial<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> 
name
 <span class="token operator">==</span> "
__main__
"<span class="token punctuation">:</span>
    x <span class="token operator">=</span> <span class="token number">5</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"factorial(</span><span class="token interpolation"><span class="token punctuation">{</span>x<span class="token punctuation">}</span></span><span class="token string">) ="</span></span><span class="token punctuation">,</span> factorial<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Python 解释器内部也维护一个“调用栈”，每个函数调用都会在栈中创建一个帧（Frame），存放局部变量和执行状态。</li>
</ul>
<hr>
<h3 id="内存管理（局部变量与函数参数）"><a href="#内存管理（局部变量与函数参数）" class="headerlink" title="内存管理（局部变量与函数参数）"></a>内存管理（局部变量与函数参数）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><strong>栈分配</strong>：编译器在编译期或运行期自动为每个函数分配固定的栈空间，用于存储局部变量和函数参数。函数结束时，这些空间会自动释放，无需程序员手动管理。</li>
<li><strong>堆分配</strong>：程序员可在运行时动态向操作系统请求内存，使用 <code>new</code>/<code>malloc</code>（C++）或创建对象（Python）。这些内存由程序员负责释放（或由垃圾回收器回收）。</li>
</ul>
<h4 id="C-示例：栈-vs-堆"><a href="#C-示例：栈-vs-堆" class="headerlink" title="C++ 示例：栈 vs 堆"></a>C++ 示例：栈 vs 堆</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">stackExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>             <span class="token comment">// 分配在栈上</span>
    <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">// 数组也分配在栈上</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b[0] = "</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 函数结束时，a 和 b 的栈空间自动释放</span>
<span class="token keyword">void</span> <span class="token function">heapExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 在堆上分配一个 int</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 在堆上分配一个大小为 100 的数组</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*p = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"arr[0] = "</span> <span class="token operator">&lt;&lt;</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>               <span class="token comment">// 释放堆内存</span>
    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>           <span class="token comment">// 释放数组</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">stackExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">heapExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>stackExample</code>：变量 <code>a</code> 和数组 <code>b</code> 分配在栈上，由系统自动分配与回收。</li>
<li><code>heapExample</code>：使用 <code>new</code> 在堆上分配内存，需要手动调用 <code>delete</code>/<code>delete[]</code> 来释放，否则会发生内存泄漏。</li>
</ul>
<h4 id="Python-示例：对象分配在堆上"><a href="#Python-示例：对象分配在堆上" class="headerlink" title="Python 示例：对象分配在堆上"></a>Python 示例：对象分配在堆上</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">memory_example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    a <span class="token operator">=</span> <span class="token number">10</span>            <span class="token comment"># 整数对象 10 存储在堆上，a 是栈帧中的一个引用</span>
    lst <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>   <span class="token comment"># 列表对象存储在堆上，lst 引用保存在栈帧</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lst<span class="token punctuation">)</span>
<span class="token keyword">if</span> 
name
 <span class="token operator">==</span> "
__main__
"<span class="token punctuation">:</span>
    memory_example<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># Python 通过引用计数和垃圾回收自动释放不再使用的对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在 Python 中，所有对象都分配在堆上，局部变量仅是对这些对象的引用，保存在栈帧中。函数退出时，局部引用消失，引用计数可能降为 0，垃圾回收器会回收对象。</li>
</ul>
<hr>
<h3 id="表达式求值（逆波兰表达式）"><a href="#表达式求值（逆波兰表达式）" class="headerlink" title="表达式求值（逆波兰表达式）"></a>表达式求值（逆波兰表达式）</h3><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>逆波兰表达式（后缀表达式）无需括号即可明确运算顺序，评估过程中需要一个栈来保存操作数、临时结果。</p>
<ul>
<li>遇到操作数时，压栈</li>
<li>遇到运算符时，从栈中弹出相应数量的操作数进行计算，并将结果压回栈</li>
<li>最后栈顶即为运算结果</li>
</ul>
<h4 id="C-示例（仅支持-四则运算）"><a href="#C-示例（仅支持-四则运算）" class="headerlink" title="C++ 示例（仅支持 + - * / 四则运算）"></a>C++ 示例（仅支持 <code>+ - * /</code> 四则运算）</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stack&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token comment">// 将字符串拆分为逆波兰表达式的 tokens</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token function">tokenize</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>expr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> tokens<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>istringstream <span class="token function">iss</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string token<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iss <span class="token operator">&gt;&gt;</span> token<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tokens<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> tokens<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>tokens<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> st<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>tk <span class="token operator">:</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tk <span class="token operator">==</span> <span class="token string">"+"</span> <span class="token operator">||</span> tk <span class="token operator">==</span> <span class="token string">"-"</span> <span class="token operator">||</span> tk <span class="token operator">==</span> "
_<span class="token string">" || tk == "</span><span class="token operator">/</span>"<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> b <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> a <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tk <span class="token operator">==</span> <span class="token string">"+"</span><span class="token punctuation">)</span> res <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tk <span class="token operator">==</span> <span class="token string">"-"</span><span class="token punctuation">)</span> res <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
_<span class="token operator">*</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tk <span class="token operator">==</span> "<span class="token operator">*</span>
"<span class="token punctuation">)</span> res <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tk <span class="token operator">==</span> <span class="token string">"/"</span><span class="token punctuation">)</span> res <span class="token operator">=</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span>tk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string expr <span class="token operator">=</span> <span class="token string">"3 4 + 2 * 7 /"</span><span class="token punctuation">;</span>
    <span class="token comment">// 对应中缀: ((3 + 4) * 2) / 7 = 2</span>
    <span class="token keyword">auto</span> tokens <span class="token operator">=</span> <span class="token function">tokenize</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Result: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>将逆波兰表达式拆为 token 数组，遍历时用 <code>std::stack&lt;int&gt;</code> 存放操作数。每遇运算符，弹出两个操作数，计算后将结果压回栈。</li>
</ul>
<h4 id="Python-示例-1"><a href="#Python-示例-1" class="headerlink" title="Python 示例"></a>Python 示例</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">eval_rpn</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span><span class="token punctuation">:</span>
    stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> tk <span class="token keyword">in</span> tokens<span class="token punctuation">:</span>
        <span class="token keyword">if</span> tk <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token string">"+"</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">,</span> "
_<span class="token string">", "</span><span class="token operator">/</span>"<span class="token punctuation">}</span><span class="token punctuation">:</span>
            b <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            a <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> tk <span class="token operator">==</span> <span class="token string">"+"</span><span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> tk <span class="token operator">==</span> <span class="token string">"-"</span><span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span>
_<span class="token operator">*</span>            <span class="token keyword">elif</span> tk <span class="token operator">==</span> "<span class="token operator">*</span>
"<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># 对于除法，需要注意 Python 的整除与 C++ 不同</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 向零取整</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>tk<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> 
name
 <span class="token operator">==</span> "
__main__
"<span class="token punctuation">:</span>
    expr <span class="token operator">=</span> <span class="token string">"3 4 + 2 * 7 /"</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Result:"</span><span class="token punctuation">,</span> eval_rpn<span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Python 用列表 <code>stack</code> 模拟栈，操作与 C++ 版本一致。</li>
</ul>
<hr>
<h3 id="撤销（Undo）操作"><a href="#撤销（Undo）操作" class="headerlink" title="撤销（Undo）操作"></a>撤销（Undo）操作</h3><p>许多应用需要实现“撤销”功能，此时可将用户操作或状态快照依次压入栈，用户点击“撤销”时，再次从栈顶弹出即可恢复到上一次状态。</p>
<h4 id="Python-示例：文本编辑器简易撤销栈"><a href="#Python-示例：文本编辑器简易撤销栈" class="headerlink" title="Python 示例：文本编辑器简易撤销栈"></a>Python 示例：文本编辑器简易撤销栈</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TextEditor</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> 
__init__
<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">""</span>
        self<span class="token punctuation">.</span>undo_stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 存放历史状态</span>
    <span class="token keyword">def</span> <span class="token function">write</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 在写新内容前，将当前状态压栈</span>
        self<span class="token punctuation">.</span>undo_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>text <span class="token operator">+=</span> s
    <span class="token keyword">def</span> <span class="token function">undo</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>undo_stack<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>text <span class="token operator">=</span> self<span class="token punctuation">.</span>undo_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Nothing to undo"</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Current Text: '</span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>text<span class="token punctuation">}</span></span><span class="token string">'"</span></span><span class="token punctuation">)</span>
<span class="token keyword">if</span> 
name
 <span class="token operator">==</span> "
__main__
"<span class="token punctuation">:</span>
    editor <span class="token operator">=</span> TextEditor<span class="token punctuation">(</span><span class="token punctuation">)</span>
    editor<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span>
    editor<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># Hello</span>
    editor<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">", World!"</span><span class="token punctuation">)</span>
    editor<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># Hello, World!</span>
    editor<span class="token punctuation">.</span>undo<span class="token punctuation">(</span><span class="token punctuation">)</span>
    editor<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># Hello</span>
    editor<span class="token punctuation">.</span>undo<span class="token punctuation">(</span><span class="token punctuation">)</span>
    editor<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># (空字符串)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>每次写入之前，将 <code>self.text</code> 的旧值压入 <code>undo_stack</code>。调用 <code>undo()</code> 时，将栈顶字符串弹出并恢复。</li>
</ul>
<hr>
<h3 id="浏览器后退功能"><a href="#浏览器后退功能" class="headerlink" title="浏览器后退功能"></a>浏览器后退功能</h3><p>浏览器维护一个“历史页面访问栈”：</p>
<ul>
<li>用户访问新页面时，将当前页面地址压入“后退栈”，同时清空“前进栈”</li>
<li>点击“后退”时，将当前页面压入“前进栈”，并从“后退栈”弹出最近访问的页面</li>
<li>点击“前进”时，则反向操作</li>
</ul>
<h4 id="Python-示例：简易浏览器历史"><a href="#Python-示例：简易浏览器历史" class="headerlink" title="Python 示例：简易浏览器历史"></a>Python 示例：简易浏览器历史</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">BrowserHistory</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> homepage<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>back_stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token comment"># 后退栈</span>
        self<span class="token punctuation">.</span>forward_stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 前进栈</span>
        self<span class="token punctuation">.</span>current <span class="token operator">=</span> homepage  <span class="token comment"># 当前页面</span>
    <span class="token keyword">def</span> <span class="token function">visit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> url<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>back_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>current<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>current <span class="token operator">=</span> url
        self<span class="token punctuation">.</span>forward_stack<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 新访问清空前进历史</span>
    <span class="token keyword">def</span> <span class="token function">back</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>back_stack<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>forward_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>current<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>current <span class="token operator">=</span> self<span class="token punctuation">.</span>back_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"No pages to go back to"</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>forward_stack<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>back_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>current<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>current <span class="token operator">=</span> self<span class="token punctuation">.</span>forward_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"No pages to go forward to"</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Back: </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>back_stack<span class="token punctuation">}</span></span><span class="token string">, Current: </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>current<span class="token punctuation">}</span></span><span class="token string">, Forward: </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>forward_stack<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    browser <span class="token operator">=</span> BrowserHistory<span class="token punctuation">(</span><span class="token string">"homepage.com"</span><span class="token punctuation">)</span>
    browser<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
    browser<span class="token punctuation">.</span>visit<span class="token punctuation">(</span><span class="token string">"news.com"</span><span class="token punctuation">)</span>
    browser<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
    browser<span class="token punctuation">.</span>visit<span class="token punctuation">(</span><span class="token string">"sports.com"</span><span class="token punctuation">)</span>
    browser<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
    browser<span class="token punctuation">.</span>back<span class="token punctuation">(</span><span class="token punctuation">)</span>
    browser<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
    browser<span class="token punctuation">.</span>back<span class="token punctuation">(</span><span class="token punctuation">)</span>
    browser<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
    browser<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token punctuation">)</span>
    browser<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>通过两个栈 (<code>back_stack</code> 和 <code>forward_stack</code>) 维护历史访问记录，实现后退和前进功能。</li>
</ul>
<hr>
<h3 id="语法分析与括号匹配"><a href="#语法分析与括号匹配" class="headerlink" title="语法分析与括号匹配"></a>语法分析与括号匹配</h3><p>在编译器或解释器的语法分析阶段，需要检查表达式或语句是否合法。最常见的是<strong>括号匹配</strong>问题：扫描字符串时，遇到左括号（<code>(</code>、<code>[</code>、<code>{</code>）时压栈，遇到右括号时检查栈顶是否是对应的左括号，若不匹配则报错；最后栈为空则匹配成功。</p>
<h4 id="C-示例：括号匹配"><a href="#C-示例：括号匹配" class="headerlink" title="C++ 示例：括号匹配"></a>C++ 示例：括号匹配</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stack&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map&gt;</span></span>
<span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> st<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> pairs <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token char">')'</span><span class="token punctuation">,</span> <span class="token char">'('</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token char">']'</span><span class="token punctuation">,</span> <span class="token char">'['</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token char">'}'</span><span class="token punctuation">,</span> <span class="token char">'{'</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'('</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'['</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'{'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">')'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">']'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'}'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pairs<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 忽略其他字符</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string s1 <span class="token operator">=</span> <span class="token string">"([{}])"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string s2 <span class="token operator">=</span> <span class="token string">"([}{])"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> s1 <span class="token operator">&lt;&lt;</span> <span class="token string">" is "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"valid\n"</span> <span class="token operator">:</span> <span class="token string">"invalid\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> s2 <span class="token operator">&lt;&lt;</span> <span class="token string">" is "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"valid\n"</span> <span class="token operator">:</span> <span class="token string">"invalid\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>使用 <code>std::stack&lt;char&gt;</code> 存储左括号，遇到右括号时检查对应关系。</li>
</ul>
<h4 id="Python-示例-2"><a href="#Python-示例-2" class="headerlink" title="Python 示例"></a>Python 示例</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">is_valid</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
    stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    pairs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">')'</span><span class="token punctuation">:</span> <span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">']'</span><span class="token punctuation">:</span> <span class="token string">'['</span><span class="token punctuation">,</span> <span class="token string">'}'</span><span class="token punctuation">:</span> <span class="token string">'{'</span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>
        <span class="token keyword">if</span> c <span class="token keyword">in</span> <span class="token string">'([{'</span><span class="token punctuation">:</span>
            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> c <span class="token keyword">in</span> <span class="token string">')]}'</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> stack <span class="token keyword">or</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> pairs<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment"># 忽略其他字符</span>
    <span class="token keyword">return</span> <span class="token keyword">not</span> stack
<span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>is_valid<span class="token punctuation">(</span><span class="token string">"([{}])"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># True</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>is_valid<span class="token punctuation">(</span><span class="token string">"([}{])"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>逻辑同上，用列表模拟栈。</li>
</ul>
<hr>
<h3 id="进程-线程调度与上下文切换"><a href="#进程-线程调度与上下文切换" class="headerlink" title="进程/线程调度与上下文切换"></a>进程/线程调度与上下文切换</h3><p>操作系统在进行<strong>线程切换</strong>或<strong>进程切换</strong>时，需要保存当前执行状态（寄存器上下文、程序计数器等）到线程/进程的<strong>栈帧</strong>中，待下次重新调度时再从栈中恢复。</p>
<ul>
<li>线程栈：每个线程分配固定大小的栈空间，保存其调用链和临时变量。上下文切换时，CPU 会自动“压栈”通用寄存器和程序计数器，然后加载下一个线程的寄存器和 PC 值；切回原线程时，再次“弹栈”恢复上下文。</li>
</ul>
<h4 id="C-伪示例（伪代码，仅用于说明概念）"><a href="#C-伪示例（伪代码，仅用于说明概念）" class="headerlink" title="C++ 伪示例（伪代码，仅用于说明概念）"></a>C++ 伪示例（伪代码，仅用于说明概念）</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">CPUContext</span> <span class="token punctuation">{</span>
    <span class="token keyword">uint64_t</span> rip<span class="token punctuation">;</span>     <span class="token comment">// 指令指针（程序计数器）</span>
    <span class="token keyword">uint64_t</span> rsp<span class="token punctuation">;</span>     <span class="token comment">// 栈指针</span>
    <span class="token keyword">uint64_t</span> regs<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 其他通用寄存器</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">context_switch</span><span class="token punctuation">(</span>CPUContext <span class="token operator">*</span>cur<span class="token punctuation">,</span> CPUContext 
_next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 保存当前上下文到 cur</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>
        <span class="token string">"mov %%rsp, %0\n\t"</span>
        <span class="token string">"mov %%rax, %1\n\t"</span>
        <span class="token comment">// … 其他寄存器</span>
_<span class="token operator">*</span>        <span class="token operator">:</span> <span class="token string">"=m"</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=m"</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">/*
 … 
_/
        :
        :
    );
    // 加载下一个上下文
    asm volatile (
        "mov %0, %%rsp\n\t"
        "mov %1, %%rax\n\t"
        // … 其他寄存器
        :
_*        : "m"(next-&gt;rsp), "m"(next-&gt;regs[0]) /*
 … */</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 跳转到下一个线程的指令地址</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"jmp *%0"</span> <span class="token double-colon punctuation">::</span> <span class="token string">"m"</span><span class="token punctuation">(</span>next<span class="token operator">-&gt;</span>rip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>该示例仅示意 OS 如何将寄存器状态压栈/存储到 <code>CPUContext</code> 结构，模拟上下文切换。真实内核会更复杂，并在内核栈上完成这些操作。</li>
</ul>
<hr>
<h3 id="实时系统任务调度与中断处理"><a href="#实时系统任务调度与中断处理" class="headerlink" title="实时系统任务调度与中断处理"></a>实时系统任务调度与中断处理</h3><p>在实时系统（RTOS）中，每个任务通常分配一个固定大小的栈，用于保存用户态执行时的局部变量和调用帧。</p>
<ul>
<li><strong>任务调度</strong>：RTOS 按优先级或时间片轮转调度任务，切换时需保存/恢复任务上下文（寄存器、程序计数器等）到各自任务的栈帧。</li>
<li><strong>中断处理</strong>：发生中断时，CPU 自动将部分寄存器（如程序计数器、标志寄存器）压入当前栈中，跳转到中断处理程序，并使用中断程序自身的栈（通常也是内核栈）执行，处理完毕后从栈中弹出恢复现场。</li>
</ul>
<h4 id="C-示例（伪代码，基于-ARM-Cortex-M-中断栈）"><a href="#C-示例（伪代码，基于-ARM-Cortex-M-中断栈）" class="headerlink" title="C 示例（伪代码，基于 ARM Cortex-M 中断栈）"></a>C 示例（伪代码，基于 ARM Cortex-M 中断栈）</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 假设 Cortex-M 架构，中断发生时硬件会自动压入 R0-R3、R12、LR、PC、xPSR</span>
<span class="token keyword">void</span> <span class="token function">SysTick_Handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 此时硬件已将通用寄存器和 xPSR 压入当前任务的栈中，使用 PSP/MSP 寄存器区分</span>
    <span class="token comment">// 处理中断逻辑</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// 退出中断时，硬件自动从栈中弹回寄存器并恢复现场</span>
<span class="token punctuation">}</span>
<span class="token comment">// 任务创建时，手动构造该任务的初始栈帧</span>
<span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token function">create_task_stack</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> <span class="token operator">*</span>stack_top<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 栈顶需预留硬件自动压栈的空间（8 寄存器）</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>stack_top<span class="token punctuation">)</span> <span class="token operator">=</span> INITIAL_xPSR<span class="token punctuation">;</span>  <span class="token comment">// xPSR</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>stack_top<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>task_func<span class="token punctuation">;</span> <span class="token comment">// PC</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>stack_top<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xFFFFFFFD</span><span class="token punctuation">;</span>    <span class="token comment">// LR (使用 PSP 指向任务栈)</span>
    <span class="token comment">// R12, R3, R2, R1, R0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>stack_top<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 接下来是软件自动压入的寄存器（R4–R11）</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>stack_top<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> stack_top<span class="token punctuation">;</span> <span class="token comment">// 返回任务上下文初始化后的栈顶指针</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在 ARM Cortex-M 系列中，中断或异常发生时，硬件会自动将 R0–R3、R12、LR、PC、xPSR 压栈；退出时硬件弹栈恢复。这段伪代码展示了如何手动为一个新任务构造“假”的中断栈帧，使其从任务函数 <code>task_func</code> 开始执行。</li>
</ul>
<hr>
<h2 id="堆与栈在内存中的分布及冲突"><a href="#堆与栈在内存中的分布及冲突" class="headerlink" title="堆与栈在内存中的分布及冲突"></a>堆与栈在内存中的分布及冲突</h2><h3 id="内存布局示意"><a href="#内存布局示意" class="headerlink" title="内存布局示意"></a>内存布局示意</h3><p>C 语言的内存模型分为 5 个区：栈区、堆区、静态区、常量区、代码区。每个区存储的内容如下：</p>
<ol>
<li>栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈。栈内存分配运算内置于 CPU 的指令集，效率很高，但是分配的内存量有限，比如 iOS 中栈区的大小是 2M。</li>
<li>堆区：就是通过 new、malloc、realloc 分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。“内存泄漏”通常说的就是堆区。</li>
<li>静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后，由系统释放。</li>
<li>常量区：常量存储在这里，不允许修改。</li>
<li>代码区：顾名思义，存放代码。</li>
</ol>
<p><img src="https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1749360547853MFckbxyUqonaQtxbuPsc8E3unsc.png" alt="1749360547853MFckbxyUqonaQtxbuPsc8E3unsc.png"><br><img src="https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/1749360556085D4ivbYK77oSejXxL204cgPNvneb.png" alt="1749360556085D4ivbYK77oSejXxL204cgPNvneb.png"></p>
<ul>
<li><strong>堆区</strong>（Heap）从低地址向高地址方向增长。当程序调用 <code>new</code>/<code>malloc</code> 分配内存时，分配器会在堆中寻找足够大的空闲块。</li>
<li><strong>栈区</strong>（Stack）从高地址向低地址方向增长。当函数调用时，系统在栈顶“向下”分配栈帧；函数返回时，“向上”回收。</li>
<li>两者通常由中间的空闲区隔开，若向对方增长的空间过大，可能出现<strong>堆与栈冲突</strong>（Stack–Heap Collision）。</li>
</ul>
<h3 id="栈堆冲突（Stack–Heap-Collision）"><a href="#栈堆冲突（Stack–Heap-Collision）" class="headerlink" title="栈堆冲突（Stack–Heap Collision）"></a>栈堆冲突（Stack–Heap Collision）</h3><p>当程序对堆申请大量连续内存（如 <code>new</code>/<code>malloc</code>）而栈调用层次过深（或线程栈空间不足）时：</p>
<ul>
<li><strong>堆过度增长</strong>：不断调用动态分配函数，导致堆区不断向高地址扩展</li>
<li><strong>栈过度生长</strong>：深度递归或大量局部变量导致栈区向低地址扩展<br>若二者相向增长，最终会相互覆盖（即“冲突”），造成已分配的堆内存或栈空间被意外覆盖，导致程序崩溃或不可预知的错误。</li>
</ul>
<h4 id="示意场景"><a href="#示意场景" class="headerlink" title="示意场景"></a>示意场景</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">recurse</span><span class="token punctuation">(</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 每次调用消耗一定的栈空间</span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 1KB 的局部数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">recurse</span><span class="token punctuation">(</span>depth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不断分配堆内存</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span> allocations<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            allocations<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每次分配 ~40KB</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Heap exhausted: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 同时进行深度递归</span>
    <span class="token function">recurse</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这会导致栈溢出</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在上述伪示例中，如果同时执行大量 <code>new int[10000]</code>（堆分配）与深度递归 <code>recurse(100000)</code>（栈分配），就可能发生堆与栈冲突。实际运行时，程序要么先出现堆分配失败（抛出 <code>bad_alloc</code>），要么先出现栈溢出 (Stack Overflow)。</li>
</ul>
<h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><ol>
<li><strong>控制递归深度</strong>，或使用迭代替代深度递归，从而减少栈空间消耗。</li>
<li><strong>限制堆分配总量</strong>，在堆分配时及时释放不再使用的内存，避免过度占用。</li>
<li><strong>增加可用内存</strong>：在嵌入式或受限环境下，根据需求调整栈大小（编译器或链接器选项）和堆区大小。</li>
<li><strong>监控与检测工具</strong>：使用工具（如 Valgrind、AddressSanitizer）检测内存越界和栈溢出问题。</li>
</ol>
<hr>
<h2 id="堆与栈在不同应用场景中的现实案例"><a href="#堆与栈在不同应用场景中的现实案例" class="headerlink" title="堆与栈在不同应用场景中的现实案例"></a>堆与栈在不同应用场景中的现实案例</h2><h3 id="嵌入式开发"><a href="#嵌入式开发" class="headerlink" title="嵌入式开发"></a>嵌入式开发</h3><ul>
<li><strong>堆与栈在 RTOS 中的角色</strong><ul>
<li><strong>栈</strong>：每个任务分配固定大小的任务栈，用于存储任务函数的调用帧和局部变量。RTOS 切换任务时，会保存/恢复任务的寄存器上下文到各自的任务栈中。</li>
<li><strong>堆</strong>：嵌入式往往内存紧张，避免动态分配；如果使用堆则要小心碎片化。许多 RTOS（如 FreeRTOS）提供“内存池”或“堆区域”管理接口，开发者可根据需求预先分配一段大内存作为堆，通过 <code>pvPortMalloc</code>/<code>vPortFree</code> 操作。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// FreeRTOS 示例：创建一个任务，并为其指定栈大小</span>
<span class="token keyword">void</span> <span class="token function">vTaskFunction</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> local_var <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>  <span class="token comment">// 存储在任务栈中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Task logic...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在创建任务时，指定 256 字 作为任务栈大小</span>
    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>vTaskFunction<span class="token punctuation">,</span> <span class="token string">"Task1"</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启动调度器，开始抢占式多任务</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>场景说明</strong>：在嵌入式系统中，为了保证实时性和预测性，往往禁止或限制堆分配，更多地使用<strong>静态分配</strong>或<strong>内存池</strong>，仅在启动阶段少量使用堆。</li>
</ul>
<hr>
<h3 id="Web-后端"><a href="#Web-后端" class="headerlink" title="Web 后端"></a>Web 后端</h3><ul>
<li><p><strong>函数调用与请求栈</strong></p>
<ul>
<li>在 Web 服务中，每个 HTTP 请求都可能触发一条线程（或使用协程/异步框架），该请求对应的调用堆栈存放在栈内存中。若请求处理链条过深（大量中间件或控制器嵌套），有可能导致栈溢出。</li>
</ul>
</li>
<li><p><strong>缓存管理</strong></p>
<ul>
<li><strong>堆</strong>：Java 或 C++ 编写的后端应用中的缓存（如 LRU Cache）通常使用堆结构来维护元素优先级或过期时间。例如，使用 <code>std::priority_queue</code> 或 Python 的 <code>heapq</code> 实现定时淘汰策略。</li>
</ul>
</li>
</ul>
<h4 id="C-示例：基于堆的简单-LRU-缓存（按过期时间）"><a href="#C-示例：基于堆的简单-LRU-缓存（按过期时间）" class="headerlink" title="C++ 示例：基于堆的简单 LRU 缓存（按过期时间）"></a>C++ 示例：基于堆的简单 LRU 缓存（按过期时间）</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">CacheItem</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> key<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string value<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span>time_point expire_time<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">CompareExpire</span> <span class="token punctuation">{</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> CacheItem <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> CacheItem <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token punctuation">.</span>expire_time <span class="token operator">&gt;</span> b<span class="token punctuation">.</span>expire_time<span class="token punctuation">;</span> <span class="token comment">// 过期时间早的优先级高</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">LRUCache</span><span class="token punctuation">(</span>size_t capacity<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">capacity_</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>value<span class="token punctuation">,</span> <span class="token keyword">int</span> ttl_seconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        CacheItem item<span class="token punctuation">{</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> now <span class="token operator">+</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span>ttl_seconds<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache_map_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> capacity_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 移除过期或最久未使用元素</span>
            <span class="token function">evict</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cache_map_<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
        min_heap_<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> it <span class="token operator">=</span> cache_map_<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> cache_map_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment">// 未命中</span>
        <span class="token comment">// 更新过期时间或移动到最新位置可自行实现</span>
        <span class="token keyword">return</span> it<span class="token operator">-&gt;</span>second<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">evict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>min_heap_<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">auto</span> <span class="token operator">&amp;</span>top <span class="token operator">=</span> min_heap_<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>top<span class="token punctuation">.</span>expire_time <span class="token operator">&lt;=</span> now<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 已过期，删除</span>
                cache_map_<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>top<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                min_heap_<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果堆顶未过期，但 cache_map_ 超过容量，可自行实现额外的 LRU 逻辑</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 这里简化：如果仍然超出容量，可额外删除最老元素</span>
    <span class="token punctuation">}</span>
    size_t capacity_<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> CacheItem<span class="token operator">&gt;</span> cache_map_<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>priority_queue<span class="token operator">&lt;</span>CacheItem<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>CacheItem<span class="token operator">&gt;</span><span class="token punctuation">,</span> CompareExpire<span class="token operator">&gt;</span> min_heap_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    LRUCache <span class="token function">cache</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Get key 1: "</span> <span class="token operator">&lt;&lt;</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 可能已过期，返回 ""</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>使用 <code>std::priority_queue</code>（最小堆）按过期时间排序，当容量满时弹出最早过期项或其他淘汰策略。</li>
</ul>
<hr>
<h3 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/KillerAery/p/10765893.html">游戏架构设计:内存管理 - KillerAery - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhyan8/p/17238161.html">【Unity3D】Unity3D 技术栈 - little_fat_sheep - 博客园</a></li>
</ul>
</blockquote>
<ul>
<li><strong>内存池（Memory Pool）</strong><ul>
<li>游戏中对象（如子弹、特效、NPC）创建频繁，反复调用 <code>new/delete</code> 会导致堆碎片和性能损耗。常用的做法是在启动时预先向堆申请一大块连续内存，将其切分为固定大小的“内存池块”，通过栈或链表管理空闲块。分配时从池中取出一个空闲块，释放时将其归还池中，而无需操作系统的堆管理。</li>
</ul>
</li>
</ul>
<h4 id="C-示例：简单对象池（以-GameObject-为例）"><a href="#C-示例：简单对象池（以-GameObject-为例）" class="headerlink" title="C++ 示例：简单对象池（以 GameObject 为例）"></a>C++ 示例：简单对象池（以 <code>GameObject</code> 为例）</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token comment">// 假设游戏对象</span>
<span class="token keyword">class</span> <span class="token class-name">GameObject</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">GameObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">set_position</span><span class="token punctuation">(</span><span class="token keyword">int</span> px<span class="token punctuation">,</span> <span class="token keyword">int</span> py<span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> px<span class="token punctuation">;</span> y <span class="token operator">=</span> py<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"GameObject at ("</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> <span class="token string">")\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">ObjectPool</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">ObjectPool</span><span class="token punctuation">(</span>size_t poolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pool_<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>poolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> poolSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            pool_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">GameObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            free_stack_<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pool_<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">ObjectPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> obj <span class="token operator">:</span> pool_<span class="token punctuation">)</span> <span class="token keyword">delete</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    GameObject<span class="token operator">*</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>free_stack_<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        GameObject<span class="token operator">*</span> obj <span class="token operator">=</span> free_stack_<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        free_stack_<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span>GameObject<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        obj<span class="token operator">-&gt;</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        free_stack_<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>GameObject<span class="token operator">*</span><span class="token operator">&gt;</span> pool_<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>stack<span class="token operator">&lt;</span>GameObject<span class="token operator">*</span><span class="token operator">&gt;</span> free_stack_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ObjectPool <span class="token function">pool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    GameObject <span class="token operator">*</span>obj1 <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    obj1<span class="token operator">-&gt;</span><span class="token function">set_position</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    obj1<span class="token operator">-&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// GameObject at (10, 20)</span>
    pool<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    GameObject <span class="token operator">*</span>obj2 <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    obj2<span class="token operator">-&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// GameObject at (0, 0) （重置后）</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>ObjectPool</code> 在构造时一次性向堆申请若干 <code>GameObject</code>，将它们全部存在 <code>pool_</code> 容器中，再把指针压入 <code>free_stack_</code>（栈）。获取时从 <code>free_stack_</code> 弹栈；释放时将对象 <code>reset()</code> 并压回栈。避免了频繁的 <code>new/delete</code>。</li>
</ul>
<hr>
<h3 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h3><ul>
<li><p><strong>线程栈</strong></p>
<ul>
<li>操作系统为每个线程分配固定大小的内存作为线程栈，用于保存函数调用帧、局部变量和中断上下文。栈空间不足会导致<strong>栈溢出（Stack Overflow）</strong>，可能使程序崩溃。</li>
</ul>
</li>
<li><p><strong>堆碎片与分配器</strong></p>
<ul>
<li>应用在堆上频繁分配/释放不同大小的块，会导致碎片化（外部碎片）。操作系统或 C 运行时使用<strong>分配算法</strong>（如伙伴系统、空闲链表、slab 分配器）来减少碎片。例如 Linux 内核使用伙伴算法（Buddy Allocator）为内核分配物理页；用户态 C 库（glibc）使用 ptmalloc2，实现复杂的 bin 快表和 mmap 分配，从而提升多线程环境下的分配效率并尽量减少碎片。</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体而言，<strong>栈</strong>与<strong>堆</strong>在数据结构和内存管理层面都是基础而关键的概念。数据结构层面，栈提供简单高效的 LIFO 存取，堆（优先队列）提供基于优先级的动态调度；内存管理层面，栈由系统自动分配释放，速度快但空间有限；堆则按需动态分配，由程序或运行时负责回收，灵活但需要注意碎片和内存泄漏。理解两者的差异及应用场景（如嵌入式的静态分配、后端的请求栈和缓存管理、游戏的内存池、操作系统的线程栈管理等）可以帮助程序员写出更健壮、高效的代码。</p>
<ul>
<li><strong>栈</strong>：自动分配与释放；访问速度快；适用于函数调用、状态机、撤销等场景；容量有限且线程私有。</li>
<li><strong>堆</strong>：动态分配与释放；灵活但开销较大；可能发生碎片；适用于缓存管理、对象池、动态数据结构等场景。</li>
<li>理解两者在内存布局上的位置及增长方式，有助于避免栈溢出和堆栈冲突，提高程序安全性与性能。</li>
</ul>

        </article>
        <section class="post-near">
            <ul>
                
                    <li>上一篇: <a href="/2025/05/01/2025-05-01-%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8/">2025-05-01-决策树算法及应用</a></li>
                
                
                    <li>下一篇: <a href="/2025/04/23/2025-04-23-%E5%9F%BA%E4%BA%8E%E4%B8%8A%E4%B8%8B%E4%BD%8D%E6%9C%BA%E7%BB%93%E6%9E%84%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/">2025-04-23-基于上下位机结构的系统实例分析</a></li>
                
            </ul>
        </section>
        
            <section class="post-tags">
            <a class="-none-link" href="/tags/course/" rel="tag">课程学习</a>
            </section>
        
    
        <section class="post-author">
        
            <figure class="author-avatar">
                <img src="https://tk-pichost-1325224430.cos.ap-chengdu.myqcloud.com/blog/20250927100251272.jpg?imageSlim" alt="ttkqwe" />
            </figure>
        
            <div class="author-info">
                <h4>ttkqwe</h4>
                <p>计算机大三学生，喜欢研究一些乱七八糟的东西，目前研究方向是深度学习。本站未注明转载的文章均为原创，并采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow">CC BY-NC-SA 4.0</a> 授权协议，<span style="color: #E91E63">转载请注明来源</span>，谢谢！</p>
            </div>
        </section>
    
    </div>
</main>

    <footer>
    <div class="buttons">
        <button class="to-top" href="#"></button>
    </div>
    <div class="wrap min">
        <section class="widget">
            <div class="row">
                <div class="col-m-4">
                    <h3 class="title-recent">最新文章：</h3>
                    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/10/15/2025-10-15-python%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F%E4%B8%8Emap%E5%87%BD%E6%95%B0/">2025-10-15-python列表推导式与map函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/10/14/2025-10-14-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%EF%BC%88Telnet%EF%BC%89/">2025-10-14-计算机网络实验二-交换机基本配置与远程登录（Telnet）</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/07/29/2025-07-29-%E4%B9%9D%E6%A0%BC%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">2025-07-29-九格通用基础大模型环境配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/07/03/2025-07-03-%E6%8B%AF%E6%95%91%E6%88%91%E7%9A%84%E2%80%9C%E9%AB%98%E7%83%A7%E2%80%9D%E6%88%98%E5%8F%8B%E2%80%94%E2%80%94Y7000P%202024%E7%89%88%E6%B8%85%E7%81%B0%E6%8D%A2%E7%A1%85%E8%84%82%E8%AE%B0%E5%BD%95/">2025-07-03-拯救我的“高烧”战友——Y7000P 2024 版清灰换硅脂记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/08/2025-06-08-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/">2025-06-08-大模型底层技术分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/05/2025-06-05-%E6%99%BA%E8%83%BD%E4%BD%93%E5%B9%B3%E5%8F%B0%E5%8F%8A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/">2025-06-05-智能体平台及关键技术分析</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-date">时光机：</h3>
                    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">十月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">七月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">六月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">五月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">四月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">二月 2025</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-tags">标签云：</h3>
                    <a href="/tags/mathematical-modeling/" style="font-size: 10px;">数学建模</a> <a href="/tags/deep-learning/" style="font-size: 14px;">深度学习</a> <a href="/tags/development/" style="font-size: 18px;">程序开发</a> <a href="/tags/algorithm/" style="font-size: 10px;">算法学习</a> <a href="/tags/algorithm-practice/" style="font-size: 16px;">算法练习</a> <a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" style="font-size: 12px;">论文阅读</a> <a href="/tags/course/" style="font-size: 20px;">课程学习</a> <a href="/tags/troubleshooting/" style="font-size: 18px;">问题解决</a>
                </div>
            </div>
        </section>
        <section class="sub-footer">
            <p>
                © 2025 <a href="/">TK的小站</a>. All Rights Reserved. Theme By <a href="https://github.com/Dreamer-Paul/Hingle" target="_blank" rel="nofollow">Hingle</a>.
                
                    &nbsp;|&nbsp;
                    <a href="https://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
                        蜀ICP备2025165253号
                    </a>
                
                
                    &nbsp;|&nbsp;
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11000002000001" target="_blank" rel="nofollow noopener" class="police-beian">
                        <span class="police-icon" aria-hidden="true"></span>
                        <span class="police-text">京公网安备11000002000001号</span>
                    </a>
                
            </p>
        </section>
    </div>
</footer>


<script src="/static/kico.js"></script>
<script src="/static/hingle.js"></script>


<script>var hingle = new Paul_Hingle({"copyright":true,"night":true});</script>

<style>
.police-beian{display:inline-flex;align-items:center;gap:4px}
.police-icon{display:inline-block;width:16px;height:16px;background:#e91e63;border-radius:2px;opacity:.85}
/* 说明：如需官方警徽图标，可将 .police-icon 的 background 设置为图片：
   background:url('https://www.beian.gov.cn/img/ghs.png') no-repeat center/contain; */
</style>

  </body>
</html>
